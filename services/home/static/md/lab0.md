# Лабораторная работа № 0
## Цель
Сформировать понимание дальнейшей работы, познакомить со структурой проекта.
## Содержание
- Структура веб-приложения
- Архитектура проекта
- Инструменты и технологии
- Порядок дальнейшей работы

## Ход работы
### Структура веб-приложения
Веб-приложение состоит из следующих компонентов:
- *Frontend* (то, что видит пользователь)
- *Backend* (серверная часть)
- *База данных*

<img src="/home/static/assets/interaction-scheme.png" style="display:block;margin:0 auto;width:80%;">

Переходя по адресу в сети, пользователь через интернет передает запросы на сервер (компьютер, на котором работает веб-приложение). Тот адрес, который ввел пользователь, обрабатывается во *Frontend* части приложения:
- Получение параметров;
- Обработка тела запроса;
- Возврат HTML-страниц;
- Маршрутизация;
- Валидация данных;
- и т.д.

**Frontend** часть приложения предназначена для отображения и валидации данных, предоставления нужных страниц и файлов, но ни в коем случае в ней не происходит обращение к базе данных и другие действие, связанные с изменением, созданием и удалением данных.

*Frontend* является лишь посредником, фильтром между пользователем и *Backend* частью сайта. *Frontend* не содержит в себе сложных вычислений, не относящихся к анимациям и отображению. Главная задача *Frontend* — предоставить пользователю удобный интерфейс для взаимодействия с *Backend*'ом. 

Так, нажимая кнопку "Создать" мы отправляем на *Frontend* POST-запрос, который содержит в себе данные. *Frontend* проводит первичную обработку, и, если с данными все в порядке, отправляет запрос на *Backend*, а пользователя уведомляет о том, что операция прошла успешно.

Да, *Frontend* и *Backend* — это независимые друга от друга приложения, работающие на разных портах (http://localhost:номер-порта) или даже на разных компьютерах. Общаются *Frontend* и *Backend* с помощью сетевых протоколов и передают данные, например, через JSON или XML. 

Веб-приложение состоит из трёх основных частей: клиентской части, серверной части и базы данных. Клиентская часть является интерфейсом для пользователя и написана на HTML, CSS, JavaScript. Серверная часть обрабатывает запросы от клиента и отвечает на них. База данных хранит информацию, которую использует веб-приложение, например, данные пользователей или контент.
---

### Архитектура проекта
Что такое **микросервисная архитектура**?

Говоря о микросервисной архитектуре, можно провести аналогию с большим домом, где каждая комната, по сути, является независимым, самодостаточным микросервисом, а соединены комнаты через двери, то есть, интерфейсы, у которых есть лишь один метод: сменитьКомнату(комната Room).

В нашем случае микросервисом является приложение, слушающее запросы по определенному порту и выдающее требуемые данные. ***Порт*** — это номер квартиры во многоэтажном доме. Вводя в строке браузера адрес http://localhost:8080/, пользователь хочет обратиться к приложению, "*слушащему*" порт 8080. Вводя адрес http://localhost:80/, пользователь обращается к приложению, работающему на порту 80.

Вот, как это выглядит в коде:
```
    package main // главный модуль программы

    import "net/http" // модуль для работы в сети

    func main() {
        handler := getHandler() // Получить экземпляр маршрутизатора
        http.ListenAndServe(":8080", handler) // Слушать и обслуживать порт ":8080" обработчиком запросов handler
    }

    func getHandler() http.Handler {
        // ...
    }
```

Таким образом, весь сайт построен на небольших независимых приложениях, общающихся между собой по сети.
---

Вот так выглядит структура папок этого проекта:

```
project
├── docker-compose.yml
├── go.mod
├── go.sum
├── services
│   ├── account
│   ├── customer
│   ├── employee
│   ├── home
│   ├── organization
│   ├── product
│   │   ├── backend
│   │   │   ├── cmd
│   │   │   ├── implementation
│   │   │   ├── repo
│   │   │   ├── service
│   │   │   └── transport
│   │   │       └── http
│   │   ├── domain
│   │   └── frontend
│   │       ├── cmd
│   │       ├── handlers
│   │       ├── router
│   │       ├── static
│   │       │   ├── assets
│   │       │   ├── html
│   │       │   ├── js
│   │       │   └── md
│   │       ├── transport
│   │       └── utils
│   ├── proxy
│   └── utils
└── static
    ├── css
    └── js

```

Работа с организациями, товарами, клиентами и т.д. вынесена в отдельные независимые сервисы. Внутри этих сервисов есть разделение на следующие директории:

- backend
- frontend
- domain

**Domain** включает в себя модель данных или *entity*. Она общая для обоих микросервисов и вынесена в отдельную папку. директории **backend** и **frontend** — два независимых приложения, работающих самостоятельно. Часто при попытке обратиться к неработающему сервису мы все равно видим страницу с надписью "*Закручиваем* *гайки*". Это означает, что сломался *backend*, но *frontend* всё равно работает. 

Микросервисный подход облегчает процесс разработки, уменьшая область видимости разработчика. Чем меньше сущностей требуется держать в голове, тем легче сконцентрироваться на текущей задаче
---

### Инструменты и технологии
- #### Язык программирования Go

В рамках всего проекта будет использоваться язык программирования **Go**.

**Go** (часто также **Golang**) — компилируемый многопоточный язык программирования, разработанный внутри компании *Google*. 
Язык *Go* разрабатывался как язык программирования для создания высокоэффективных программ, работающих на современных распределённых системах и многоядерных процессорах. Он может рассматриваться как попытка создать замену языкам *Си* и *C++* с учётом изменившихся компьютерных технологий и накопленного опыта разработки крупных систем. По словам Роба Пайка, «Go был разработан для решения реальных проблем, возникающих при разработке программного обеспечения в Google»

Основными требованиями к языку стали:
- Язык должен предоставлять небольшое число средств, не повторяющих функциональность друг друга.
- Простая и регулярная грамматика. Минимум ключевых слов, простая, легко разбираемая грамматическая структура, легко читаемый код.
- Простая работа с типами. Типизация должна обеспечивать безопасность, но не превращаться в бюрократию, лишь увеличивающую код. Отказ от иерархии типов, но с сохранением объектно-ориентированных возможностей.
- Отсутствие неявных преобразований.
- Сборка мусора.
- Встроенные средства распараллеливания, простые и эффективные.
- Поддержка строк, ассоциативных массивов и коммуникационных каналов.
- Чёткое разделение интерфейса и реализации.
- Эффективная система пакетов с явным указанием зависимостей, обеспечивающая быструю сборку.

Golang принято использовать для серверной части, но во избежание увеличения сложности проекта, Go будет использоваться и во Frontend части.
---

- #### HTML, CSS, JavaScript

Весь веб-контент строится с помощью HTML, CSS и JavaScript

**HTML** — язык разметки страниц. Состоит из открывающих и закрывающих тегов и представляет **содержание** страницы.

**CSS** — набор стилей, описывающих оформление страницы.

**JavaScript** — язык, на котором работает Web. Установлен во всех браузерах по умолчанию. JavaScript используется для того, чтобы "*оживить*" страницу. Анимации, валидаторы, уведомления, связь с серверной частью — все это осуществляется через JavaScript.

Так как HTML, CSS и JavaScript заслуживают отдельной дисциплины, в проекте будут использоваться самые базовые вещи, а также готовые стили CSS. Это не помешает понять принципы работы Frontend, но заметно упростит разработку сервиса.

HTML — содержание страницы, CSS — оформление страницы, JavaScript — динамика страницы.
---

- #### Visual Studio Code

Бесплатная легковесная IDE. Поддерживает множество языков программирования, имеет большое сообщество, одна из самых популярных IDE в мире.

- #### Docker

**Docker** — платформа, позволяющая "*запаковывать*" приложения в виде образов (OS Linux + приложение и все необходимые ресурсы и библиотеки) и воспроизводить их в контейнере (виртуальная машина, на которой запущен образ).

- #### PostgreSQL

**PostgreSQL** — система управления базой данных с открытым исходным кодом.

### Порядок дальнейшей работы

Работа над проектом начнется с определения **ER-модели** (схемы данных). Основываясь на этой модели, необходимо сформировать перечень микросервисов, номера портов и затрагиваемые таблицы для каждого микросервиса.

Следующий этап — проектирование микросервисов один за другим. Проектирование включает (в порядке реализации):
- создание таблиц;
- backend-часть;
- тестирование API с помощью postman;
- frontend-часть;
- размещение микросервиса с помощью Docker.

Так, реализовывая микросервисы один за другим, получится создать масштабируемую, модульную систему управления документами в виде веб-приложения, контейниризированного с помощью Docker.
---

Да прибудет с вами сила!
---
